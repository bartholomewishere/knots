<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trefoil Knot</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #ffffff;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
        }
        input[type="range"] {
            width: 200px;
        }
        .value {
            display: inline-block;
            margin-left: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3 style="margin-top: 0;">Knot Viewer</h3>
        
        <label>Knot Type</label>
        <select id="knotType" style="width: 100%; padding: 8px; border-radius: 4px; margin-bottom: 10px;">
            <option value="trefoil">Trefoil Knot (3_1)</option>
            <option value="figure8">Figure-Eight Knot (4_1)</option>
            <option value="cinquefoil">Cinquefoil Knot (5_1)</option>
            <option value="granny">Granny Knot (3_1 # 3_1)</option>
            <option value="torus">Torus Knot (2,3)</option>
            <option value="torus53">Torus Knot (5,3)</option>
            <option value="unknot">Unknot (Circle)</option>
        </select>
        
        <button id="pauseBtn">Pause Rotation</button>
        
        <button id="exportBtn" style="background: #28a745;">Export as Image</button>
        
        <label>Tube Radius: <span class="value" id="radiusValue">0.40</span></label>
        <input type="range" id="radius" min="0.1" max="0.8" step="0.05" value="0.4">
        
        <label>Segments: <span class="value" id="segmentsValue">200</span></label>
        <input type="range" id="segments" min="50" max="400" step="50" value="200">
        
        <label>Color</label>
        <input type="color" id="color" value="#808080">
        
        <label>Zoom: <span class="value" id="zoomValue">8.0</span></label>
        <input type="range" id="zoom" min="3" max="15" step="0.5" value="8">
        
        <div class="info">
            üí° Drag to rotate manually<br>
            üñ±Ô∏è Scroll to zoom
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, trefoilMesh;
        let isRotating = true;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let currentKnot = 'trefoil';
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
            
            // Create trefoil
            createTrefoil();
            
            // Controls
            setupControls();
            setupMouseControls();
            setupZoomControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Animation
            animate();
        }
        
        function trefoilParametric(t) {
            const knotType = currentKnot;
            
            switch(knotType) {
                case 'trefoil':
                    return new THREE.Vector3(
                        Math.sin(t) + 2 * Math.sin(2 * t),
                        Math.cos(t) - 2 * Math.cos(2 * t),
                        -Math.sin(3 * t)
                    );
                
                case 'figure8':
                    return new THREE.Vector3(
                        (2 + Math.cos(2 * t)) * Math.cos(3 * t),
                        (2 + Math.cos(2 * t)) * Math.sin(3 * t),
                        Math.sin(4 * t)
                    );
                
                case 'cinquefoil':
                    return new THREE.Vector3(
                        Math.sin(t) + 2 * Math.sin(2 * t),
                        Math.cos(t) - 2 * Math.cos(2 * t),
                        -Math.sin(5 * t)
                    );
                
                case 'granny':
                    const shift = t < Math.PI ? 0 : 2;
                    const localT = t < Math.PI ? t : t - Math.PI;
                    return new THREE.Vector3(
                        Math.sin(localT) + 2 * Math.sin(2 * localT) + shift,
                        Math.cos(localT) - 2 * Math.cos(2 * localT),
                        -Math.sin(3 * localT)
                    );
                
                case 'torus':
                    const p = 2, q = 3;
                    const r = Math.cos(q * t) + 2;
                    return new THREE.Vector3(
                        r * Math.cos(p * t),
                        r * Math.sin(p * t),
                        -Math.sin(q * t)
                    );
                
                case 'torus53':
                    const p2 = 5, q2 = 3;
                    const r2 = Math.cos(q2 * t) + 2;
                    return new THREE.Vector3(
                        r2 * Math.cos(p2 * t),
                        r2 * Math.sin(p2 * t),
                        -Math.sin(q2 * t)
                    );
                
                case 'unknot':
                    return new THREE.Vector3(
                        3 * Math.cos(t),
                        3 * Math.sin(t),
                        0
                    );
                
                default:
                    return new THREE.Vector3(
                        Math.sin(t) + 2 * Math.sin(2 * t),
                        Math.cos(t) - 2 * Math.cos(2 * t),
                        -Math.sin(3 * t)
                    );
            }
        }
        
        function createTrefoil() {
            const segments = parseInt(document.getElementById('segments').value);
            const radius = parseFloat(document.getElementById('radius').value);
            const color = document.getElementById('color').value;
            
            // Create curve
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * Math.PI * 2;
                points.push(trefoilParametric(t));
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            curve.closed = true;
            
            // Create tube geometry
            const tubeGeometry = new THREE.TubeGeometry(curve, segments, radius, 32, true);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.3,
                flatShading: false
            });
            
            // Remove old mesh if exists
            if (trefoilMesh) {
                scene.remove(trefoilMesh);
                trefoilMesh.geometry.dispose();
                trefoilMesh.material.dispose();
            }
            
            trefoilMesh = new THREE.Mesh(tubeGeometry, material);
            scene.add(trefoilMesh);
        }
        
        function setupControls() {
            const radiusSlider = document.getElementById('radius');
            const segmentsSlider = document.getElementById('segments');
            const colorPicker = document.getElementById('color');
            const pauseBtn = document.getElementById('pauseBtn');
            const knotTypeSelect = document.getElementById('knotType');
            const zoomSlider = document.getElementById('zoom');
            const exportBtn = document.getElementById('exportBtn');
            
            knotTypeSelect.addEventListener('change', (e) => {
                currentKnot = e.target.value;
                createTrefoil();
            });
            
            radiusSlider.addEventListener('input', (e) => {
                document.getElementById('radiusValue').textContent = e.target.value;
                createTrefoil();
            });
            
            segmentsSlider.addEventListener('input', (e) => {
                document.getElementById('segmentsValue').textContent = e.target.value;
                createTrefoil();
            });
            
            colorPicker.addEventListener('input', () => {
                createTrefoil();
            });
            
            pauseBtn.addEventListener('click', () => {
                isRotating = !isRotating;
                pauseBtn.textContent = isRotating ? 'Pause Rotation' : 'Resume Rotation';
            });
            
            zoomSlider.addEventListener('input', (e) => {
                const zoomValue = parseFloat(e.target.value);
                camera.position.z = zoomValue;
                document.getElementById('zoomValue').textContent = zoomValue.toFixed(1);
            });
            
            exportBtn.addEventListener('click', () => {
                exportImage();
            });
        }
        
        function setupMouseControls() {
            const container = document.getElementById('container');
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging && trefoilMesh) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    trefoilMesh.rotation.y += deltaX * 0.01;
                    trefoilMesh.rotation.x += deltaY * 0.01;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Touch support for mobile
            container.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            });
            
            container.addEventListener('touchmove', (e) => {
                if (isDragging && trefoilMesh) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;
                    
                    trefoilMesh.rotation.y += deltaX * 0.01;
                    trefoilMesh.rotation.x += deltaY * 0.01;
                    
                    previousMousePosition = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                }
            });
            
            container.addEventListener('touchend', () => {
                isDragging = false;
            });
        }
        
        function setupZoomControls() {
            const container = document.getElementById('container');
            const zoomSlider = document.getElementById('zoom');
            
            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const zoomSpeed = 0.5;
                const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                
                let newZoom = camera.position.z + delta;
                newZoom = Math.max(3, Math.min(15, newZoom)); // Clamp between 3 and 15
                
                camera.position.z = newZoom;
                zoomSlider.value = newZoom;
                document.getElementById('zoomValue').textContent = newZoom.toFixed(1);
            }, { passive: false });
        }
        
        function exportImage() {
            // Store original size
            const originalWidth = renderer.domElement.width;
            const originalHeight = renderer.domElement.height;
            
            // Set high resolution (4x current size)
            const exportWidth = window.innerWidth * 4;
            const exportHeight = window.innerHeight * 4;
            
            renderer.setSize(exportWidth, exportHeight);
            camera.aspect = exportWidth / exportHeight;
            camera.updateProjectionMatrix();
            
            // Render one high-res frame
            renderer.render(scene, camera);
            
            // Get the canvas data as image
            const link = document.createElement('a');
            link.download = `knot_${currentKnot}_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
            
            // Restore original size
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotate only if not paused and not dragging
            if (isRotating && !isDragging && trefoilMesh) {
                trefoilMesh.rotation.x += 0.003;
                trefoilMesh.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
    </script>
</body>
</html>
